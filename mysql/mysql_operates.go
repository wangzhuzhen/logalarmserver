package mysql

import (
	"fmt"
	"database/sql"
//	"reflect"
	_ "github.com/go-sql-driver/mysql"
	"github.com/wangzhuzhen/logalarmserver/types"
)


func ConnectMYSQL() (*sql.DB, error) {
	/*DSN数据源名称
	  [username[:password]@][protocol[(address)]]/dbname[?param1=value1¶mN=valueN]
	  user@unix(/path/to/socket)/dbname
	  user:password@tcp(localhost:5555)/dbname?charset=utf8&autocommit=true
	  user:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname?charset=utf8mb4,utf8
	  user:password@/dbname
	  无数据库: user:password@/
	*/
	db, err := sql.Open("mysql", "root:123456@tcp(127.0.0.1:3306)/?charset=utf8") //第一个参数为驱动名
	if err != nil {
		return nil, err
	}
	return db, nil
}

func CreteDatabase(db *sql.DB, dbname string) {

	_, err := db.Query("create database if not exists "  + dbname)
	checkErr(err)
}

func CreteTable_Rules(db *sql.DB, dbname string) {
	_, err := db.Query("create table if not exists  "+ dbname + ".rules(ruleowner varchar(255), rulename varchar(255), keyword varchar(255), " +
		"keywordindex int, timewindow int, thresholdnum int, emaillist varchar(2048));")
	//db.Query("create table if not exists logalarm.ruletab(c1 int, c2 varchar(20), c3 varchar(20))")
	checkErr(err)
}

//插入数据
func InsertData_Rules(db *sql.DB, dbname string, rule types.Rule) {

	//stmt, err := db.Prepare("INSERT " + dbname + ".rules SET c1=?,c2=?,c3=?") //Prepare creates a prepared statement for later queries or executions.
	stmt, err := db.Prepare("INSERT " + dbname + ".rules SET ruleowner=?,rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=?")
	checkErr(err)

	//res, err := stmt.Exec("wangzhuzhen", "Rule004", "DEBUG", 8, 30, 5, "wang_zhuzhen@dahuatech.com") //Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.
	res, err := stmt.Exec(rule.RuleOwner, rule.RuleName, rule.KeyWord, rule.KeywordIndex, rule.TimeWindow, rule.ThresholdNum, rule.EmailList)
	checkErr(err)

	id, err := res.LastInsertId() //LastInsertId returns the integer generated by the database in response to a command.
	checkErr(err)

	fmt.Println("Last insert id :", id)
}

func CreteTable_Topology(db *sql.DB, dbname string) {
	//_, err := db.Query("create table if not exists  "+ dbname + ".topology" +  "(c1 int, c2 varchar(20), c3 varchar(20), c4 int);")
	_, err := db.Query("create table if not exists  "+ dbname + ".topology(topologyname varchar(255), appname varchar(255), submit int, ruleowner varchar(255), " +
		"rulename varchar(255), keyword varchar(255), keywordindex int, timewindow int, thresholdnum int, emaillist varchar(2048));")
	//db.Query("create table if not exists logalarm.ruletab(c1 int, c2 varchar(20), c3 varchar(20))")
	checkErr(err)
}

func InsertData_Topology(db *sql.DB, dbname string) {

	//stmt, err := db.Prepare("INSERT " + dbname + ".topology SET c1=?,c2=?,c3=?,c4=?") //Prepare creates a prepared statement for later queries or executions.
	stmt, err := db.Prepare("INSERT " + dbname + ".topology SET topologyname=?,appname=?,submit=?,ruleowner=?,rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=?")
	checkErr(err)

	res, err := stmt.Exec("abc.abc.abc", "app.123.456.1214", 0, "wangzhuzhen", "Rule004", "Debug", 8, 30, 5, "wang_zhuzhen@dahuatech.com") //Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.
	checkErr(err)

	id, err := res.LastInsertId() //LastInsertId returns the integer generated by the database in response to a command.
	checkErr(err)

	fmt.Println("Last insert id :", id)
}

//更新数据
func UpdateData_Rule(db *sql.DB, dbname string, rule types.Rule ) {

	stmt, err := db.Prepare("update " + dbname + ".rules set rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=? where ruleowner=?")
	checkErr(err)

	res, err := stmt.Exec(rule.RuleName, rule.KeyWord, rule.KeywordIndex, rule.TimeWindow, rule.ThresholdNum,rule.EmailList,rule.RuleOwner)
	checkErr(err)

	affect, err := res.RowsAffected() //RowsAffected returns the number of rows affected by an
	// update, insert, or delete.
	checkErr(err)

	fmt.Println("受影响的行数 : ", affect)
}

//更新数据
func UpdateData_Topology(db *sql.DB, dbname string ) {

	stmt, err := db.Prepare("update " + dbname + ".topology set topologyname=? where submit=?")
	checkErr(err)

	res, err := stmt.Exec("abc.EFG.xyz", 0)
	checkErr(err)

	affect, err := res.RowsAffected() //RowsAffected returns the number of rows affected by an
	// update, insert, or delete.
	checkErr(err)

	fmt.Println("受影响的行数 : ", affect)
}

//查询所有数据
func SelectData_Rules(db *sql.DB, dbname string)  ([]types.Rule, error) {

	var rules []types.Rule
	rows, err := db.Query("select * from "+ dbname + ".rules")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)
		temp := types.Rule{RuleOwner: ruleowner,RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		rules = append(rules,temp)

		/*
		fmt.Printf("[ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return rules,nil
}

//查询用户数据
func Select_UserRules(db *sql.DB, dbname string, user types.RuleUser )  ([]types.Rule, error) {

	var rules []types.Rule
	rows, err := db.Query("select * from "+ dbname + ".rules where ruleowner='" + user.Username+"'")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)
		temp := types.Rule{RuleOwner: ruleowner,RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		rules = append(rules,temp)

		/*
		fmt.Printf("[ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return rules,nil
}


//查询数据
func SelectData_Topology(db *sql.DB, dbname string) {

	rows, err := db.Query("select * from "+ dbname + ".topology")
	checkErr(err)

	for rows.Next() {
		var topologyname  string
		var appname       string
		var submit        int
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&topologyname, &appname, &submit,&ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)

		fmt.Printf("[topologyname]: %s  [appname]: %s  [submit]: %d  [ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", topologyname, appname, submit, ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
	}
}

//删除数据
func DeleteRule(db *sql.DB, dbname string, drule types.DeletedRule) {

	stmt, err := db.Prepare("delete from "+dbname + ".rules where ruleowner=? and rulename=?")
	checkErr(err)

	res, err := stmt.Exec(drule.RuleOwner, drule.RuleName)
	checkErr(err)

	affect, err := res.RowsAffected()
	checkErr(err)

	fmt.Println("删除的行数:", affect)
}

//删除数据
func DeleteTopology(db *sql.DB, dbname string) {

	stmt, err := db.Prepare("delete from "+dbname + ".topology where topologyname=?")
	checkErr(err)

	res, err := stmt.Exec("aaa.bbb.ccc")
	checkErr(err)

	affect, err := res.RowsAffected()
	checkErr(err)

	fmt.Println("删除的行数:", affect)
}


func checkErr(errMasg error) {
	if errMasg != nil {
		panic(errMasg)
	}
}
/*
func printResult(query *sql.Rows) {
	column, _ := query.Columns()              //读出查询出的列字段名
	values := make([][]byte, len(column))     //values是每个列的值，这里获取到byte里
	scans := make([]interface{}, len(column)) //因为每次查询出来的列是不定长的，用len(column)定住当次查询的长度
	for i := range values {                   //让每一行数据都填充到[][]byte里面
		scans[i] = &values[i]
	}
	results := make(map[int]map[string]string) //最后得到的map
	i := 0
	for query.Next() { //循环，让游标往下移动
		if err := query.Scan(scans...); err != nil { //query.Scan查询出来的不定长值放到scans[i] = &values[i],也就是每行都放在values里
			fmt.Println(err)
			return
		}
		row := make(map[string]string) //每行数据
		for k, v := range values {     //每行数据是放在values里面，现在把它挪到row里
			key := column[k]
			row[key] = string(v)
		}
		results[i] = row //装入结果集中
		i++
	}
	for k, v := range results { //查询出来的数组
		fmt.Println(k, v)
	}
}
*/


