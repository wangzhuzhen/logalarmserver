package mysql

import (
	"fmt"
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"github.com/wangzhuzhen/logalarmserver/types"
)

/* 连接Mysql数据库 */
func ConnectMYSQL() (*sql.DB, error) {
	/*DSN数据源名称
	  [username[:password]@][protocol[(address)]]/dbname[?param1=value1¶mN=valueN]
	  user@unix(/path/to/socket)/dbname
	  user:password@tcp(localhost:5555)/dbname?charset=utf8&autocommit=true
	  user:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname?charset=utf8mb4,utf8
	  user:password@/dbname
	  无数据库: user:password@/
	*/
	db, err := sql.Open("mysql", "root:123456@tcp(127.0.0.1:3306)/?charset=utf8") //第一个参数为驱动名
	if err != nil {
		return nil, err
	}
	return db, nil
}

/* 创建用户数据库 */
func CreteDatabase(db *sql.DB, dbname string) {

	_, err := db.Query("create database if not exists "  + dbname)
	checkErr(err)
}

/* 创建日志报警规则表 */
func CreteTable_Rule(db *sql.DB, dbname string) {
	_, err := db.Query("create table if not exists  "+ dbname + ".rules(ruleowner varchar(255), rulename varchar(255), keyword varchar(255), " +
		"keywordindex int, timewindow int, thresholdnum int, emaillist varchar(2048));")
	checkErr(err)
}

/* 日志报警规则表中插入数据 */
func Insert_Rule(db *sql.DB, dbname string, rule types.Rule) {

	stmt, err := db.Prepare("INSERT " + dbname + ".rules SET ruleowner=?,rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=?")
	checkErr(err)

	res, err := stmt.Exec(rule.RuleOwner, rule.RuleName, rule.KeyWord, rule.KeywordIndex, rule.TimeWindow, rule.ThresholdNum, rule.EmailList)
	checkErr(err)

	id, err := res.LastInsertId() //LastInsertId returns the integer generated by the database in response to a command.
	checkErr(err)

	fmt.Println("Last insert id :", id)
}

/* 日志报警规则表中更新指定用户指定规则的数据 */
func Update_Rule(db *sql.DB, dbname string, rule types.Rule ) {

	stmt, err := db.Prepare("update " + dbname + ".rules set keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=? where ruleowner=? and rulename=?")
	checkErr(err)

	res, err := stmt.Exec(rule.KeyWord, rule.KeywordIndex, rule.TimeWindow, rule.ThresholdNum, rule.EmailList, rule.RuleOwner, rule.RuleName)
	checkErr(err)

	affect, err := res.RowsAffected() //RowsAffected returns the number of rows affected by an
	// update, insert, or delete.
	checkErr(err)

	fmt.Println("受影响的行数 : ", affect)
	if (affect == 0) {
		fmt.Println("No matched rule to update for [ruleowner=" +rule.RuleOwner +" rulename=" + rule.RuleName +"] or matched rule not necessary to update")
	}
}

/* 查看日志报警规则表 */
func Select_Rules(db *sql.DB, dbname string)  ([]types.Rule, error) {

	var rules []types.Rule
	rows, err := db.Query("select * from "+ dbname + ".rules")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)
		temp := types.Rule{RuleOwner: ruleowner,RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		rules = append(rules,temp)

		/*
		fmt.Printf("[ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return rules,nil
}

/* 查看指定用户的日志报警规则表 */
func Select_UserRules(db *sql.DB, dbname string, user string )  ([]types.Rule, error) {

	var rules []types.Rule
	rows, err := db.Query("select * from "+ dbname + ".rules where ruleowner='" + user+"'")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)
		temp := types.Rule{RuleOwner: ruleowner,RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		rules = append(rules,temp)

		/*
		fmt.Printf("[ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return rules,nil
}

/* 删除报警规则表中指定用户指定规则名称的数据 */
func DeleteRule(db *sql.DB, dbname string, drule types.RuleUser) {

	stmt, err := db.Prepare("delete from "+dbname + ".rules where ruleowner=? and rulename=?")
	checkErr(err)

	res, err := stmt.Exec(drule.RuleOwner, drule.RuleName)
	checkErr(err)

	affect, err := res.RowsAffected()
	checkErr(err)
	if (affect == 0) {
		fmt.Println("No matched rule to delete for [ruleowner=" +drule.RuleOwner +" rulename=" + drule.RuleName +"]")
	}

	fmt.Println("删除的行数:", affect)
}

/* 创建日志报警任务表 */
func CreteTable_Topology(db *sql.DB, dbname string) {

	_, err := db.Query("create table if not exists  "+ dbname + ".topology(topologyowner varchar(255), topologyname varchar(255), appname varchar(255), submitted int, ruleowner varchar(255), " +
		"rulename varchar(255), keyword varchar(255), keywordindex int, timewindow int, thresholdnum int, emaillist varchar(2048));")
	checkErr(err)
}

/* 日志报警任务表中插入数据 */
func Insert_Topology(db *sql.DB, dbname string, topology types.Topology) {

	stmt, err := db.Prepare("INSERT " + dbname + ".topology SET topologyowner=?,topologyname=?,appname=?,submitted=?,ruleowner=?,rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=?")
	checkErr(err)

	res, err := stmt.Exec(topology.TopologyOwner, topology.TopologyName, topology.AppName, topology.Submitted, topology.RuleOwner,
		topology.RuleName, topology.KeyWord, topology.KeywordIndex, topology.TimeWindow, topology.ThresholdNum, topology.EmailList)
	checkErr(err)

	id, err := res.LastInsertId() //LastInsertId returns the integer generated by the database in response to a command.
	checkErr(err)

	fmt.Println("Last insert id :", id)
}


/* 查看日志报警任务表 */
func Select_Topologys(db *sql.DB, dbname string) ([]types.Topology, error) {

	var topologys []types.Topology
	rows, err := db.Query("select * from "+ dbname + ".topology")
	if err != nil {
		checkErr(err)
	}

	for rows.Next() {
		var topologyowner string
		var topologyname  string
		var appname       string
		var submitted     int
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&topologyowner,&topologyname, &appname, &submitted, &ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)

		temp := types.Topology{TopologyOwner: topologyowner, TopologyName: topologyname, AppName: appname, Submitted: submitted, RuleOwner: ruleowner, RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		topologys = append(topologys,temp)

		/*
		fmt.Printf("[topologyname]: %s  [appname]: %s  [submit]: %d  [ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", topologyname, appname, submit, ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return topologys, nil
}

/* 查看日志报警任务表中指定用户的报警任务 */
func Select_UserTopologys(db *sql.DB, dbname string, user string )  ([]types.Topology, error) {

	var topologys []types.Topology
	rows, err := db.Query("select * from "+ dbname + ".topology where topologyowner='" + user + "'")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var topologyowner string
		var topologyname  string
		var appname       string
		var submitted     int
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&topologyowner,&topologyname, &appname, &submitted, &ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)

		temp := types.Topology{TopologyOwner: topologyowner, TopologyName: topologyname, AppName: appname, Submitted: submitted, RuleOwner: ruleowner, RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		topologys = append(topologys,temp)

		/*
		fmt.Printf("[topologyname]: %s  [appname]: %s  [submit]: %d  [ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", topologyname, appname, submit, ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return topologys, nil
}


/* 日志报警任务表中更新指定用户指定规则的数据 */
func Update_Topology(db *sql.DB, dbname string, topology types.Topology) {

	stmt, err := db.Prepare("update " + dbname + ".topology set appname=?,submitted=?,ruleowner=?,rulename=?,keyword=?,keywordindex=?,timewindow=?,thresholdnum=?,emaillist=? where topologyowner=? and topologyname=?")
	checkErr(err)

	res, err := stmt.Exec(topology.AppName, topology.Submitted, topology.RuleOwner, topology.RuleName, topology.KeyWord, topology.KeywordIndex, topology.TimeWindow, topology.ThresholdNum, topology.EmailList, topology.TopologyOwner, topology.TopologyName)
	checkErr(err)

	affect, err := res.RowsAffected() //RowsAffected returns the number of rows affected by an
	// update, insert, or delete.
	checkErr(err)

	fmt.Println("受影响的行数 : ", affect)
	if (affect == 0) {
		fmt.Println("No matched topology to update for [topologyowner=" +topology.TopologyOwner +" topologyname=" + topology.TopologyName +"] or matched topology not necessary to update")
	}
}


/* 删除报警任务表中指定用户指定任务名称的数据 */
func DeleteTopology(db *sql.DB, dbname string, dtopology types.TopologyUser) {

	stmt, err := db.Prepare("delete from "+dbname + ".topology where topologyowner=? and topologyname=?")
	checkErr(err)

	res, err := stmt.Exec(dtopology.TopologyOwner, dtopology.TopologyName)
	checkErr(err)

	affect, err := res.RowsAffected()
	checkErr(err)
	if (affect == 0) {
		fmt.Println("No matched topology to delete for [topologyowner=" +dtopology.TopologyOwner +" topologyname=" + dtopology.TopologyName +"]")
	}

	fmt.Println("删除的行数:", affect)
}

func checkErr(errMasg error) {
	if errMasg != nil {
		panic(errMasg)
	}
}

/* 选择报警任务表中指定用户指定任务名称的数据用于提交报警 */
func Select_SubmitTopology(db *sql.DB, dbname string, user types.TopologyUser)  ([]types.Topology, error) {

	var topologys []types.Topology
	rows, err := db.Query("select * from "+ dbname + ".topology where topologyowner='" + user.TopologyOwner + "' and topologyname='" + user.TopologyName + "'")
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var topologyowner string
		var topologyname  string
		var appname       string
		var submitted     int
		var ruleowner     string
		var rulename      string
		var keyword       string
		var keywordindex  int
		var timewindow    int
		var thresholdnum  int
		var emaillist     string

		err := rows.Scan(&topologyowner,&topologyname, &appname, &submitted, &ruleowner, &rulename, &keyword, &keywordindex, &timewindow, &thresholdnum, &emaillist)
		checkErr(err)

		temp := types.Topology{TopologyOwner: topologyowner, TopologyName: topologyname, AppName: appname, Submitted: submitted, RuleOwner: ruleowner, RuleName: rulename, KeyWord: keyword, KeywordIndex: keywordindex, TimeWindow: timewindow, ThresholdNum: thresholdnum, EmailList: emaillist}
		topologys = append(topologys,temp)

		/*
		fmt.Printf("[topologyname]: %s  [appname]: %s  [submit]: %d  [ruleowner]: %s  [rulename]: %s  [keyword]: %s  [keywordindex]: %d  [timewindow]: %d  " +
			"[thresholdnum]: %d  [maillist]: %s\n", topologyname, appname, submitted, ruleowner, rulename, keyword, keywordindex, timewindow, thresholdnum, emaillist)
		*/
	}
	return topologys, nil
}

/*
func printResult(query *sql.Rows) {
	column, _ := query.Columns()              //读出查询出的列字段名
	values := make([][]byte, len(column))     //values是每个列的值，这里获取到byte里
	scans := make([]interface{}, len(column)) //因为每次查询出来的列是不定长的，用len(column)定住当次查询的长度
	for i := range values {                   //让每一行数据都填充到[][]byte里面
		scans[i] = &values[i]
	}
	results := make(map[int]map[string]string) //最后得到的map
	i := 0
	for query.Next() { //循环，让游标往下移动
		if err := query.Scan(scans...); err != nil { //query.Scan查询出来的不定长值放到scans[i] = &values[i],也就是每行都放在values里
			fmt.Println(err)
			return
		}
		row := make(map[string]string) //每行数据
		for k, v := range values {     //每行数据是放在values里面，现在把它挪到row里
			key := column[k]
			row[key] = string(v)
		}
		results[i] = row //装入结果集中
		i++
	}
	for k, v := range results { //查询出来的数组
		fmt.Println(k, v)
	}
}
*/


